<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Ping Projects</title><link>https://cardosojoao.github.io/post/</link><description>Recent content in Posts on Ping Projects</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 28 Aug 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://cardosojoao.github.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>My developmen environment</title><link>https://cardosojoao.github.io/p/development-environment/</link><pubDate>Thu, 28 Aug 2025 00:00:00 +0000</pubDate><guid>https://cardosojoao.github.io/p/development-environment/</guid><description>&lt;img src="https://cardosojoao.github.io/p/development-environment/cover.jpg" alt="Featured image of post My developmen environment" /&gt;&lt;p&gt;My development environment is based on windows desktop using VSCode as editor with a collections of extension and CSpect for ZX Spectrum Next Emulation and also ZX Spectrum Next hardware.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cardosojoao.github.io/p/development-environment/diagram.jpg"
width="714"
height="564"
srcset="https://cardosojoao.github.io/p/development-environment/diagram_hu_779e3d044e5469d7.jpg 480w, https://cardosojoao.github.io/p/development-environment/diagram_hu_afdf4c4ff3d8027f.jpg 1024w"
loading="lazy"
alt="Diagram"
class="gallery-image"
data-flex-grow="126"
data-flex-basis="303px"
&gt;&lt;/p&gt;
&lt;h2 id="tools"&gt;Tools
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Visual Studio Code (VS Code)&lt;/strong&gt; is a lightweight, open-source, and highly extensible code editor from Microsoft that supports multiple programming languages, debugging, Git integration, and a rich ecosystem of extensions for efficient development.&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://code.visualstudio.com/download" target="_blank" rel="noopener"
&gt;https://code.visualstudio.com/download&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;sjasmplus&lt;/strong&gt; is a powerful Z80 assembler that provides advanced features and flexibility for Spectrum Next development.&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://github.com/z00m128/sjasmplus" target="_blank" rel="noopener"
&gt;https://github.com/z00m128/sjasmplus&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;CSpect&lt;/strong&gt; is a Spectrum Next emulator that delivers near full hardware accuracy, allowing software to run almost exactly as it would on the real machine.&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://mdf200.itch.io/cspect" target="_blank" rel="noopener"
&gt;https://mdf200.itch.io/cspect&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;GitHub&lt;/strong&gt; is a platform for hosting and collaborating on code projects, enabling version control and teamwork through Git in the cloud.&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://github.com/" target="_blank" rel="noopener"
&gt;https://github.com/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;The &lt;strong&gt;ZX Spectrum Next&lt;/strong&gt; is a modern reimagining of the classic ZX Spectrum, offering enhanced hardware while staying true to the original’s spirit.&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://www.specnext.com/" target="_blank" rel="noopener"
&gt;https://www.specnext.com/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Hardware remote debug Remote&lt;/strong&gt; debugging from real hardware is possible by connecting the ZX Spectrum Next joystick port to your PC via USB.&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://www.amazon.es/-/pt/dp/B07LH95J24/ref=sr_1_2?crid=HSHSJ9CA7249&amp;amp;dib=eyJ2IjoiMSJ9.H2BTHlbtWYfLfNArbbhQroLZCqfoI7oux5ocaU7n9rcAlC3sCrMTz0vHL07LuAE4L72wNA9C11wxCg91MTZJsUDNNKzjlC4J99_zfO6JobPzPYyzZFtvCf8W9StuiN7-jo34oEvN1_Eufq6wMj6j7DfhXexiKsoVj2ahs7HEIIvrfsKMeTXtTFJWm2eIelB3BS4Cdna8WDzVPd7IAauclGdGXdqjtieaBjKvvxqz1zbZM2SHdKMXmKXOS6FqonOodlwqiudBe9ZWL6CddIhdIRiH7aA2xbfzL9iB-vr-Sgs.G2ulRaKX4CxV3tMt7OXhfnqcd59YwsDFoZIKz5yAg4U&amp;amp;dib_tag=se&amp;amp;keywords=6&amp;#43;Pin&amp;#43;FTDI&amp;#43;FT232RL&amp;#43;USB&amp;#43;To&amp;#43;Serial&amp;#43;Adapter&amp;#43;m%C3%B3dulo&amp;#43;USB&amp;#43;TO&amp;#43;TTL&amp;#43;RS232&amp;#43;cabo&amp;amp;qid=1756330702&amp;amp;s=electronics&amp;amp;sprefix=6&amp;#43;pin&amp;#43;ftdi&amp;#43;ft232rl&amp;#43;usb&amp;#43;to&amp;#43;serial&amp;#43;adapter&amp;#43;m%C3%B3dulo&amp;#43;usb&amp;#43;to&amp;#43;ttl&amp;#43;rs232&amp;#43;cabo%2Celectronics%2C223&amp;amp;sr=1-2" target="_blank" rel="noopener"
&gt;6 Pin FTDI FT232RL USB To Serial Adapter módulo USB TO TTL RS232 cabo&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="vscode-extensions"&gt;VSCode Extensions
&lt;/h2&gt;&lt;p&gt;VSCode is the beating heart of my coding world, supercharged by countless plugins that make every development task smoother and more powerful.&lt;/p&gt;
&lt;p&gt;I supercharge VSCode with a curated set of extensions that elevate Z80 assembly development to the same power and convenience as modern languages like C.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ASM Code Lens&lt;/strong&gt; A language server that enables code lens, references, hover information, symbol renaming and the outline view for assembler files.&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://marketplace.visualstudio.com/items?itemName=maziac.asm-code-lens" target="_blank" rel="noopener"
&gt;https://marketplace.visualstudio.com/items?itemName=maziac.asm-code-lens&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;DeZog&lt;/strong&gt; is a powerful Z80 debugger plugin for VSCode, offering advanced tools to make Spectrum Next development efficient and precise.&lt;/p&gt;
&lt;p&gt;My favourite extension makes debugging easier and more powerful than ever—it’s like a Swiss Army knife for developers.&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://marketplace.visualstudio.com/items?itemName=maziac.dezog" target="_blank" rel="noopener"
&gt;https://marketplace.visualstudio.com/items?itemName=maziac.dezog&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;NEX-FileViewer&lt;/strong&gt; adds a readonly file viewer for ZX Spectrum NEX files. .nex is a special file format for loading ZX Next programs. The viewer shows registers, a memory dump and the included screen images.&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://marketplace.visualstudio.com/items?itemName=maziac.nex-fileviewer" target="_blank" rel="noopener"
&gt;https://marketplace.visualstudio.com/items?itemName=maziac.nex-fileviewer&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Z80 Assembly meters&lt;/strong&gt; meters clock cycles and bytecode size from Z80 assembly source code.&lt;/p&gt;
&lt;p&gt;Forget the T-state cheat sheet, instantly see instruction cycles and byte sizes as you code.&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://marketplace.visualstudio.com/items?itemName=theNestruo.z80-asm-meter" target="_blank" rel="noopener"
&gt;https://marketplace.visualstudio.com/items?itemName=theNestruo.z80-asm-meter&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Z80 Instruction Set&lt;/strong&gt; Provides documentation of the Z80 instructions on hovering.&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://marketplace.visualstudio.com/items?itemName=maziac.z80-instruction-set" target="_blank" rel="noopener"
&gt;https://marketplace.visualstudio.com/items?itemName=maziac.z80-instruction-set&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Todo&lt;/strong&gt; Tree Show TODO, FIXME, etc. comment tags in a tree view&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://marketplace.visualstudio.com/items?itemName=Gruntfuggly.todo-tree" target="_blank" rel="noopener"
&gt;https://marketplace.visualstudio.com/items?itemName=Gruntfuggly.todo-tree&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="resources"&gt;Resources
&lt;/h2&gt;&lt;p&gt;There’s a massive amount of information out there, you just need to know where to look. Here’s my curated list of the essentials.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class="link" href="https://www.specnext.com/" target="_blank" rel="noopener"
&gt;https://www.specnext.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Spectrum Next discord server&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://luckyredfish.com/" target="_blank" rel="noopener"
&gt;https://luckyredfish.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://zx.remysharp.com/" target="_blank" rel="noopener"
&gt;https://zx.remysharp.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://www.youtube.com/watch?v=Nphrf14ZRpI&amp;amp;list=PLK49nPX3nslseUVUj_ZYk7YL95-v4LlLY" target="_blank" rel="noopener"
&gt;Jim Bagley tutorials&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://www.assemblytutorial.com/" target="_blank" rel="noopener"
&gt;https://www.assemblytutorial.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="http://z80-heaven.wikidot.com/math" target="_blank" rel="noopener"
&gt;http://z80-heaven.wikidot.com/math&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://www.patreon.com/c/u27217558/home" target="_blank" rel="noopener"
&gt;https://www.patreon.com/c/u27217558/home&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://www.patreon.com/c/mikedailly/posts" target="_blank" rel="noopener"
&gt;https://www.patreon.com/c/mikedailly/posts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;These are the tools and resources that power my development workflow, but they’re by no means the only options out there. The Spectrum Next community is full of amazing alternatives, so explore, experiment, and find the setup that works best for you.&lt;/p&gt;</description></item><item><title>Game Physics</title><link>https://cardosojoao.github.io/p/engine-phsyics/</link><pubDate>Tue, 19 Aug 2025 00:00:00 +0000</pubDate><guid>https://cardosojoao.github.io/p/engine-phsyics/</guid><description>&lt;img src="https://cardosojoao.github.io/p/engine-phsyics/cover.jpg" alt="Featured image of post Game Physics" /&gt;&lt;h2 id="inside-the-dot8-physics-engine"&gt;Inside the dot8 Physics Engine
&lt;/h2&gt;&lt;p&gt;Building a physics engine isn’t just about moving objects—it’s about creating a consistent and believable world. Rigidbodies define how objects react to forces, gravity, and collisions, while colliders determine the shape and boundaries for those interactions. Together, they form the backbone of any physics simulation, enabling everything from subtle character movement to complex dynamic environments. Understanding how these components work together is key for developers who want precision, performance, and realism in their games. Mastering these fundamentals isn’t just a technical skill—it’s what transforms code into immersive experiences.&lt;/p&gt;
&lt;h3 id="rigidbody-motion-in-action"&gt;Rigidbody: Motion in Action
&lt;/h3&gt;&lt;p&gt;A Rigidbody defines how an entity moves in the game world:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Velocity - 2D vector for movement per frame.&lt;/li&gt;
&lt;li&gt;Acceleration - Enables force-based motion.&lt;/li&gt;
&lt;li&gt;Gravity - Global or per object (set to 0 for flying entities).&lt;/li&gt;
&lt;li&gt;Damping/Friction - Gradually reduces speed for smooth stops.&lt;/li&gt;
&lt;li&gt;Integration Step - Updates position each frame with a fixed timestep.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-text" data-lang="text"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;struct Rigidbody
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;ID db 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;ObjectID db 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Flags db 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;VelocityX dw 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;VelocityY dw 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;AccelerationX dw 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;AccelerationY dw 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;FrictionX dw 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;FrictionY dw 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;ConstantAcceleration dw 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;ForceDuration db 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;State db 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;FSM dw 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; ends
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Key Insight: A Rigidbody doesn’t detect collisions — it only updates position based on forces.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="collider-the-silent-watcher"&gt;Collider: The Silent Watcher
&lt;/h3&gt;&lt;p&gt;-A Collider focuses on where interactions happen. In retro engines, this is usually an AABB (Axis-Aligned Bounding Box):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Offset - Position offset from the entity’s origin to align with the sprite.&lt;/li&gt;
&lt;li&gt;Size - Defines collision area.&lt;/li&gt;
&lt;li&gt;Trigger Flag - Marks collider as “non-physical” (no bounce/push, only events).&lt;/li&gt;
&lt;li&gt;Layer/Mask - Filters what this collider interacts with (e.g., Player layer vs. Enemy layer).&lt;/li&gt;
&lt;li&gt;Response - None (for triggers) or simple reaction (bounce, stop).&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-text" data-lang="text"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; struct Collider
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;ID db
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;ObjectID db 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Flags db 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;OffsetX db 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;OffsetY db 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Width db 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Height db 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Layer db 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;EventCollision dw 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;EventTrigger db 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; ends
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Key Insight: A Collider never moves objects — it only reports contacts.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;video src="colliders.mp4" width="480" height="360" controls&gt;&lt;/video&gt;&lt;/p&gt;
&lt;p&gt;See Colliders in action&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="why-keep-them-separate"&gt;Why Keep Them Separate?
&lt;/h3&gt;&lt;p&gt;Splitting Rigidbody and Collider gives dot8:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Modularity - An object can have physics without collision, or vice versa.&lt;/li&gt;
&lt;li&gt;Performance - Collider checks can be optimized separately.&lt;/li&gt;
&lt;li&gt;Flexibility - Triggers and sensors can exist without affecting motion.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;Rigidbodies and Colliders work together to bring physics to life. One controls movement, the other defines interaction. Simple, but powerful. How will you use them in your game?&lt;/p&gt;</description></item><item><title>Dot8 - Engine Sub Systems</title><link>https://cardosojoao.github.io/p/engine-sub-system/</link><pubDate>Tue, 12 Aug 2025 00:00:00 +0000</pubDate><guid>https://cardosojoao.github.io/p/engine-sub-system/</guid><description>&lt;img src="https://cardosojoao.github.io/p/engine-sub-system/cover.jpg" alt="Featured image of post Dot8 - Engine Sub Systems" /&gt;&lt;p&gt;The dot8 retro game engine is composed of distinct subsystems, each designed with a clear role in mind to ensure smooth collaboration and maintainability. By assigning dedicated responsibilities—such as rendering graphics, processing user input, or managing audio—these modular components interact harmoniously while remaining independent in their logic and operation. This separation not only streamlines development and debugging but also allows for flexibility in updating or swapping out features without disrupting the whole system. The result is an engine where each piece does its job efficiently, contributing to a cohesive and robust framework for building classic gaming experiences.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cardosojoao.github.io/p/engine-sub-system/diagram.jpg"
width="894"
height="553"
srcset="https://cardosojoao.github.io/p/engine-sub-system/diagram_hu_647824bd086e0a79.jpg 480w, https://cardosojoao.github.io/p/engine-sub-system/diagram_hu_1f9446fb542e5b86.jpg 1024w"
loading="lazy"
alt="Diagram"
class="gallery-image"
data-flex-grow="161"
data-flex-basis="387px"
&gt;&lt;/p&gt;
&lt;h2 id="physic-engine"&gt;Physic Engine
&lt;/h2&gt;&lt;p&gt;The physics engine handles how objects move and react to forces like velocity and gravity. It updates positions each frame and supports basic dynamics for things like jumping or falling, while keeping performance in mind for 8-bit hardware.&lt;/p&gt;
&lt;h2 id="audio-system"&gt;Audio System
&lt;/h2&gt;&lt;p&gt;The audio system plays music and sound effects using PT3 files. It can trigger sounds from gameplay events and supports music playback that runs independently of the main game loop, giving life to the game world.&lt;/p&gt;
&lt;h2 id="input-system"&gt;Input System
&lt;/h2&gt;&lt;p&gt;The input system reads controls from the keyboard or joystick and translates them into game actions. It supports responsive input handling for player movement, menu navigation, or interactive gameplay triggers.&lt;/p&gt;
&lt;h2 id="render-engine"&gt;Render Engine
&lt;/h2&gt;&lt;p&gt;The render engine draws all visible objects to the screen based on their position and sprite. It ensures correct layering and only draws what&amp;rsquo;s necessary, keeping the frame rate smooth and the visuals crisp.&lt;/p&gt;
&lt;h2 id="sprite-system"&gt;Sprite System
&lt;/h2&gt;&lt;p&gt;The sprite system manages visual tiles and frame data used to display characters, enemies, and effects. It pulls graphics from sprite sheets and handles flipping or offsetting for clean and flexible rendering.&lt;/p&gt;
&lt;h2 id="animation-system"&gt;Animation System
&lt;/h2&gt;&lt;p&gt;This system controls how sprites animate over time. It changes frames based on timing and states, allowing characters to walk, jump, or attack smoothly. It also supports keyframe-based events during animations.&lt;/p&gt;
&lt;h2 id="entity-manager"&gt;Entity Manager
&lt;/h2&gt;&lt;p&gt;The entity manager keeps track of all game objects. It handles creating, updating, and removing objects efficiently during gameplay and ensures each object is correctly processed in the game loop.&lt;/p&gt;
&lt;h2 id="scene-manager"&gt;Scene Manager
&lt;/h2&gt;&lt;p&gt;The scene manager loads and switches between different levels or screens. It resets objects, positions the camera, and prepares the environment when moving between gameplay, menus, or cutscenes&lt;/p&gt;
&lt;h2 id="collision-system"&gt;Collision System
&lt;/h2&gt;&lt;p&gt;The collision system checks for overlaps between objects, like when the player hits a wall or enemy. It uses simple box checks (AABB) and helps the game react to hits, blocks, or pickups instantly.&lt;/p&gt;
&lt;h2 id="trigger--event-system"&gt;Trigger / Event System
&lt;/h2&gt;&lt;p&gt;This system manages special zones or timed actions. When the player steps on a trigger or a timer finishes, it fires an event—like opening a door, playing a sound, or switching animation state.&lt;/p&gt;
&lt;h2 id="camera-system"&gt;Camera System
&lt;/h2&gt;&lt;p&gt;The camera system follows the player or focuses on key areas of the scene. It ensures that only part of the world is visible on screen, adding cinematic control and smooth scrolling to the game.&lt;/p&gt;
&lt;h2 id="asset-loader"&gt;Asset Loader
&lt;/h2&gt;&lt;p&gt;The asset loader handles loading sprites, music, level data, and configuration from memory or external files. It prepares everything needed before the game starts or when switching scenes.&lt;/p&gt;
&lt;h2 id="debug-tools"&gt;Debug Tools
&lt;/h2&gt;&lt;p&gt;The debug tools provide visibility into what’s happening inside the engine. They can show object positions, active collisions, memory usage, or FPS counters on screen. These tools help test levels, tune performance, and catch bugs quickly—especially useful during development on limited hardware like the Spectrum Next.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;As I bring all these systems together, I’m turning the dot8 retro game engine into my creative playground right now. Whether I’m debugging, exploring, or building brand new worlds, the engine lets me bring my ideas to life with excitement and ease. I’m proving that with smart design and a passion for games, even the simplest tools can make something truly fun—right here, in this very moment.&lt;/p&gt;</description></item><item><title>dot8 - Entity Manager</title><link>https://cardosojoao.github.io/p/engine-entities/</link><pubDate>Mon, 04 Aug 2025 00:00:00 +0000</pubDate><guid>https://cardosojoao.github.io/p/engine-entities/</guid><description>&lt;img src="https://cardosojoao.github.io/p/engine-entities/cover4.jpg" alt="Featured image of post dot8 - Entity Manager" /&gt;&lt;p&gt;&lt;img src="https://cardosojoao.github.io/p/engine-entities/diagram.jpg"
width="2208"
height="648"
srcset="https://cardosojoao.github.io/p/engine-entities/diagram_hu_c4f1eb00a440514e.jpg 480w, https://cardosojoao.github.io/p/engine-entities/diagram_hu_1db83c04d2f8d35a.jpg 1024w"
loading="lazy"
alt="Diagram"
class="gallery-image"
data-flex-grow="340"
data-flex-basis="817px"
&gt;&lt;/p&gt;
&lt;p&gt;In the engine, entities materialized as game objects, which serve as containers for all relevant data and behaviour. Each game object typically holds references to components such as sprite, physics body, collider, and logic scripts. This modular design allows flexibility in defining varied entities—like players, enemies, items, or triggers—by composing them from shared building blocks.&lt;/p&gt;
&lt;h2 id="game-object-properties"&gt;Game object properties
&lt;/h2&gt;&lt;h3 id="id"&gt;Id
&lt;/h3&gt;&lt;p&gt;Is a distinct, engine-assigned identifier given to each game object at creation time. It ensures that every object can be individually referenced, tracked, or compared, even if multiple objects share the same type, tag, or position.&lt;/p&gt;
&lt;h3 id="tag"&gt;Tag
&lt;/h3&gt;&lt;p&gt;A short identifier string or byte value that describes the object’s logical category (e.g., &amp;ldquo;enemy&amp;rdquo;, &amp;ldquo;bullet&amp;rdquo;, &amp;ldquo;checkpoint&amp;rdquo;). Tags are used to group or filter game objects during logic checks, such as collision response or trigger activation. Unlike class types, tags are flexible and can be changed at runtime.&lt;/p&gt;
&lt;h3 id="flags"&gt;Flags
&lt;/h3&gt;&lt;p&gt;Is a bitfield property that stores multiple binary (on/off) attributes for a game object using a single byte or word. Each bit in the flags value represents a specific toggleable property or state, such as enabled, or don’t destroy.&lt;/p&gt;
&lt;h3 id="parent"&gt;Parent
&lt;/h3&gt;&lt;p&gt;is a reference to another game object that acts as the logical or spatial parent of this object. It links a child object to its parent, allowing it to inherit position, state, or behaviour hierarchically.&lt;/p&gt;
&lt;h3 id="x"&gt;X
&lt;/h3&gt;&lt;p&gt;Represents the object&amp;rsquo;s horizontal position within the scene or world coordinate system. It defines how far the object is placed from the left edge of the scene, measured in pixels.&lt;/p&gt;
&lt;h3 id="y"&gt;Y
&lt;/h3&gt;&lt;p&gt;Represents the object&amp;rsquo;s vertical position within the scene or world coordinate system. It defines how far the object is placed from the top edge of the scene, measured in pixels.&lt;/p&gt;
&lt;h3 id="fsm"&gt;FSM
&lt;/h3&gt;&lt;p&gt;A Finite State Machine (FSM) is a way to control behaviour by dividing it into a fixed number of states, where each state defines what the object is doing. At any moment, the object is in one state, and it can switch to another based on conditions or events.&lt;/p&gt;
&lt;h3 id="fsm-state"&gt;FSM State
&lt;/h3&gt;&lt;p&gt;is a value that represents the current behaviour or mode of a game object within a finite state machine (FSM). Each value corresponds to a specific state, such as idle, walking, jumping, or attacking.&lt;/p&gt;
&lt;h3 id="collider"&gt;Collider
&lt;/h3&gt;&lt;p&gt;The collider component defines the physical size and collision behaviour of a game object. It can be assigned to both rigid and non-rigid entities. The collider does not handle physics simulation itself (e.g. gravity or forces) but acts as a collision shape and provides hooks for event responses when overlapping or contacting other objects.&lt;/p&gt;
&lt;h3 id="rigidbody"&gt;Rigidbody
&lt;/h3&gt;&lt;p&gt;The Rigidbody component controls how a game object moves over time based on velocity, applied forces, and optionally gravity. It defines dynamic motion separate from collision boundaries, allowing for smooth, physically influenced movement like falling, sliding, or being pushed.&lt;/p&gt;
&lt;h3 id="sprite"&gt;Sprite
&lt;/h3&gt;&lt;p&gt;The Sprite component defines how a game object is visually rendered on screen. It contains information about the sprite’s size, position offset, which spritesheet to use, and the current frame to display from the spritesheet.&lt;/p&gt;
&lt;h3 id="animation"&gt;Animation
&lt;/h3&gt;&lt;p&gt;The Animation component manages how a game object’s sprite is animated over time. It tracks the current animation state, controls the frame rate, steps through keyframes, and handles event triggers tied to specific frames. It also includes a small finite state machine (FSM) to manage transitions between different animations (e.g., idle, walk, jump, attack).&lt;/p&gt;
&lt;h3 id="timer"&gt;Timer
&lt;/h3&gt;&lt;p&gt;The Timer component is used to trigger events after a specified number of frames. It can be configured to fire once or loop continuously, making it ideal for timed effects, delays, cooldowns, or periodic actions.&lt;/p&gt;
&lt;h3 id="path"&gt;Path
&lt;/h3&gt;&lt;p&gt;The Path component moves a game object along a predefined series of points, creating automated. It supports a custom speed, directional travel, and options to run once, loop, or ping-pong back and forth.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-text" data-lang="text"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; struct Object
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;ID db 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Tag db 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Flags db 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;PosX dw 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;PosY dw 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Parent db 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;State db 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;FSM dw 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;SpriteComp db 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;PhysicComp db 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;AnimationComp db 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;ColliderComp db 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;PathComp db 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;TimerComp db 0
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; ends
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;The &lt;strong&gt;Object&lt;/strong&gt; structure holds all the key data for each entity in the game. It is stored as a fixed-size block in memory, making it easy and fast to access in assembly. This simple layout helps the engine update and draw many objects efficiently, while keeping the code clean and organized.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;As I continue building the dot8 engine, I constantly find myself relying on the Entity Manager it’s really the heartbeat of everything. Right now, it’s the system that keeps track of all active objects in the scene, from enemies and bullets to triggers and NPCs. It decides which entities get updated, drawn, or removed each frame. Without it, the game world would fall apart. It’s not flashy, but it quietly orchestrates the entire flow of gameplay, ensuring every component knows where it belongs. And as the engine grows, the Entity Manager keeps proving itself as the glue that holds all the pieces together.&lt;/p&gt;</description></item></channel></rss>