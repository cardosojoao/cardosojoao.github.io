[{"content":"During the resolution of my core engine growing beyond 8 KB, I analyzed the impact of splitting the engine into multiple functional blocks — for example, physics, render, and input. While exploring that approach, I also considered allowing the engine core to page itself in and out, dynamically loading the needed memory bank before calling a specific function. Although that design was later dropped, I decided to keep the prototype paging routine for a similar purpose.\nThe goal is to call functions that may reside in different memory pages, automatically page in the required 8 KB block, execute the function, and then restore the previous mapping. This approach allows managing up to eight 8 KB pages (64 KB total), each mapped into bank #0 as needed.\nAddress Structure As mentioned in a previous article, the Z80 address bus is 16-bit, which allows addressing 64 KB at once. To identify both the memory page and the function address, we can split the 16-bit address this way:\nBits Meaning Range 15–13 Page index 0 – 7 12–0 Function address 0 – 8191 Each 8 KB page contains 8192 bytes (2¹³), so the top 3 bits of a 16-bit value can define which page to load, and the lower 13 bits specify the address within that page.\nThis means functions must be compiled to execute in bank #0, since only that slot is dynamically paged.\nFunction definition example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 mmu $0000, DEBUG_BANK org $0000 @Proxy_Show_Collider equ (Proxy_Bank\u0026lt;\u0026lt;13)+Debug_Show_Collider Debug_Show_Collider: ld hl, Collider_Active_Cache .Loop: ld a, (hl) ld iyl, a inc hl ld a, (hl) inc hl ld iyh, a or iyl ret z push hl call Debug.DrawCollider pop hl jr .Loop The function itself isn’t important — what matters is the structure. The label @Proxy_Show_Collider follows the defined format: top 3 bits = page index, remaining 13 bits = function address.\nExample Call 1 2 3 call ProxyCall dw @Proxy_Show_Collider call CleanData The ProxyCall routine interprets the function pointer, pages in the correct page into bank #0, calls the target function, and restores the previous page afterward.\nThe ProxyCall Routine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ;------------------------------------------------------------ ; ProxyCall ; Dynamically pages in the target bank and calls its function ;------------------------------------------------------------ ; ; Expected: ; (SP) → proxy call function address (ppp aaaaaaaaaaaaa) ; p = page 0..7, a = 0..8191 ; ProxyCall: pop hl ld e, (hl) inc hl ld d, (hl) inc hl push hl We use a call instruction to reach this routine, so the next instruction’s address (the return address) is already on the stack, by popping it into HL, reading the following word into DE, and pushing HL back, we obtain the target function address while preserving the return address.\n1 2 3 4 5 6 7 8 9 10 11 12 ld hl, (SLOT_0000) push hl push af ex de, hl ld a, h add a, a adc a, a adc a, a adc a, a and %00000111 add PROXY_BASE_BANK call setbank0000_8k Here we store the current page in use by bank #0, preserve register A, extract the page index from the top bits of H, and map the corresponding page.\n1 2 3 ld a, h and %00011111 ld h, a his ensures that only the lower 13 bits of HL remain — the actual function address.\n1 2 pop af call Call_hl After restoring register A, we call Call_hl, which is a simple jp (hl) — effectively acting as a call (hl) pseudo-opcode.\n1 2 pop hl jp setbanks0000_hl Finally, we restore the original bank to slot #0 and return execution to the next instruction (call CleanData in the example).\nExample of Equivalent Inline Bank Switch 1 2 3 4 5 6 7 8 9 10 ld a, (SLOT_0000) push af ld a, $00 call setbank0000_8k ; ; routine code ; pop af call setbank0000_8k ret Performance Notes Call Type Size T-States ProxyCall 31 bytes 167 t-states Regular call 14 bytes 85 t-states The proxy adds roughly 82 extra t-states but saves 11 bytes per function, which is a reasonable trade-off for infrequently called routines.\nClosing Thoughts This proxy-based approach adds flexibility for managing large engines that exceed 8 KB while keeping the main memory footprint small. Although not ideal for performance-critical routines, it’s a clean and modular way to access code spread across multiple pages — an elegant solution for large Z80 projects like the Spectrum Next.\n","date":"2025-10-30T00:00:00Z","image":"https://cardosojoao.github.io/p/proxy_call/cover_proxy_call_hu_569e74d19c0eb0c3.jpg","permalink":"https://cardosojoao.github.io/p/proxy_call/","title":"function call page memory auto mapping"},{"content":"The Z80 has a 16-bit address bus, which means it can only access 64KB of memory at once. On the Spectrum Next, that space is split into eight 8KB banks that you can swap in and out as needed, kind of like changing disks in a drive, but much faster. By mapping different pages of memory into those banks, I can control which parts of the game are active depending on what’s happening.\nMy project’s architecture is built around three big blocks:\nData (the assets and state) Engine (the core systems) Game (the actual logic and content) Each block takes up one or more memory pages. That setup worked perfectly for a while, until I hit the wall. My core engine, all packed into a single 8KB page, finally ran out of space.\nI knew it was coming. I’d already split the scene renderer and audio player into separate pages, but the main engine — physics, rendering, animation — was still all in one place. So, time to rethink.\nMy first idea was to break the engine into multiple pages, grouping things by function: physics on one, rendering on another, collision on a third. It sounded tidy in theory… but in practice, it got messy fast.\nSome systems needed both the core engine and a feature page loaded at once, which meant juggling multiple banks just to get basic things running. My mapping logic was starting to look like spaghetti.\nThen, during one of my test runs, something clicked. The issue wasn’t really about code size, it was about the relationship between data and code. The core engine functions always needed to work with their data at the same time. If they lived on different pages, I was wasting banks just to keep them both accessible.\nSo I flipped the approach: instead of separating data and engine code, I brought them together. Each type of data (like entities) now lives in the same page as the functions that operate on it. When a page is active, everything it needs is already there , no extra mapping, no juggling banks.\nAfter reorganizing things this way, everything just clicked. The system ran smoother, and I even freed up around 2KB in the core engine page. That may not sound like much, but on an 8-bit machine, that’s like finding hidden treasure.\nBut to make this work, I had to rethink how my whole project was structured. Originally, everything was organized into those three main blocks — data, engine, and game — and that structure still makes sense. It keeps things logically separated and easier to maintain.\nThe solution wasn’t to abandon that structure, but to add a new build layer on top of it. This build system takes pieces from each block and organizes them according to the needs of a specific build. That way, I still keep my core architecture clean and modular, but I also gain the flexibility to assemble memory pages differently depending on the build requirements.\nIn the end, this approach gave me the best of both worlds: a well-structured project that’s easy to maintain, and a flexible build process that can adapt to different memory layouts or even alternative build schemas in the future.\nEvery pixel, every system, and every line of code in dot8 brings me closer to capturing that perfect retro feeling — precise, responsive, and alive. What about you — how would you design your ideal retro engine?\n","date":"2025-10-26T00:00:00Z","image":"https://cardosojoao.github.io/p/8k_page/cover_8k_hu_c8fd5f379f82392f.jpg","permalink":"https://cardosojoao.github.io/p/8k_page/","title":"When 8KB Isn’t Enough"},{"content":"My development environment is based on windows desktop using VSCode as editor with a collections of extension and CSpect for ZX Spectrum Next Emulation and also ZX Spectrum Next hardware.\nTools Visual Studio Code (VS Code) is a lightweight, open-source, and highly extensible code editor from Microsoft that supports multiple programming languages, debugging, Git integration, and a rich ecosystem of extensions for efficient development.\nhttps://code.visualstudio.com/download\nsjasmplus is a powerful Z80 assembler that provides advanced features and flexibility for Spectrum Next development.\nhttps://github.com/z00m128/sjasmplus\nCSpect is a Spectrum Next emulator that delivers near full hardware accuracy, allowing software to run almost exactly as it would on the real machine.\nhttps://mdf200.itch.io/cspect\nGitHub is a platform for hosting and collaborating on code projects, enabling version control and teamwork through Git in the cloud.\nhttps://github.com/\nThe ZX Spectrum Next is a modern reimagining of the classic ZX Spectrum, offering enhanced hardware while staying true to the original’s spirit.\nhttps://www.specnext.com/\nHardware remote debug Remote debugging from real hardware is possible by connecting the ZX Spectrum Next joystick port to your PC via USB.\n6 Pin FTDI FT232RL USB To Serial Adapter módulo USB TO TTL RS232 cabo\nVSCode Extensions VSCode is the beating heart of my coding world, supercharged by countless plugins that make every development task smoother and more powerful.\nI supercharge VSCode with a curated set of extensions that elevate Z80 assembly development to the same power and convenience as modern languages like C.\nASM Code Lens A language server that enables code lens, references, hover information, symbol renaming and the outline view for assembler files.\nhttps://marketplace.visualstudio.com/items?itemName=maziac.asm-code-lens\nDeZog is a powerful Z80 debugger plugin for VSCode, offering advanced tools to make Spectrum Next development efficient and precise.\nMy favourite extension makes debugging easier and more powerful than ever—it’s like a Swiss Army knife for developers.\nhttps://marketplace.visualstudio.com/items?itemName=maziac.dezog\nNEX-FileViewer adds a readonly file viewer for ZX Spectrum NEX files. .nex is a special file format for loading ZX Next programs. The viewer shows registers, a memory dump and the included screen images.\nhttps://marketplace.visualstudio.com/items?itemName=maziac.nex-fileviewer\nZ80 Assembly meters meters clock cycles and bytecode size from Z80 assembly source code.\nForget the T-state cheat sheet, instantly see instruction cycles and byte sizes as you code.\nhttps://marketplace.visualstudio.com/items?itemName=theNestruo.z80-asm-meter\nZ80 Instruction Set Provides documentation of the Z80 instructions on hovering.\nhttps://marketplace.visualstudio.com/items?itemName=maziac.z80-instruction-set\nTodo Tree Show TODO, FIXME, etc. comment tags in a tree view\nhttps://marketplace.visualstudio.com/items?itemName=Gruntfuggly.todo-tree\nResources There’s a massive amount of information out there, you just need to know where to look. Here’s my curated list of the essentials.\nhttps://www.specnext.com/ Spectrum Next discord server https://luckyredfish.com/ https://zx.remysharp.com/ Jim Bagley tutorials https://www.assemblytutorial.com/ http://z80-heaven.wikidot.com/math https://www.patreon.com/c/u27217558/home https://www.patreon.com/c/mikedailly/posts These are the tools and resources that power my development workflow, but they’re by no means the only options out there. The Spectrum Next community is full of amazing alternatives, so explore, experiment, and find the setup that works best for you.\n","date":"2025-08-28T00:00:00Z","image":"https://cardosojoao.github.io/p/development-environment/cover_hu_a3f9d62476c192cc.jpg","permalink":"https://cardosojoao.github.io/p/development-environment/","title":"My developmen environment"},{"content":"Inside the dot8 Physics Engine Building a physics engine isn’t just about moving objects—it’s about creating a consistent and believable world. Rigidbodies define how objects react to forces, gravity, and collisions, while colliders determine the shape and boundaries for those interactions. Together, they form the backbone of any physics simulation, enabling everything from subtle character movement to complex dynamic environments. Understanding how these components work together is key for developers who want precision, performance, and realism in their games. Mastering these fundamentals isn’t just a technical skill—it’s what transforms code into immersive experiences.\nRigidbody: Motion in Action A Rigidbody defines how an entity moves in the game world:\nVelocity - 2D vector for movement per frame. Acceleration - Enables force-based motion. Gravity - Global or per object (set to 0 for flying entities). Damping/Friction - Gradually reduces speed for smooth stops. Integration Step - Updates position each frame with a fixed timestep. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct Rigidbody ID db 0 ObjectID db 0 Flags db 0 VelocityX dw 0 VelocityY dw 0 AccelerationX dw 0 AccelerationY dw 0 FrictionX dw 0 FrictionY dw 0 ConstantAcceleration dw 0 ForceDuration db 0 State db 0 FSM dw 0 ends Key Insight: A Rigidbody doesn’t detect collisions — it only updates position based on forces.\nCollider: The Silent Watcher -A Collider focuses on where interactions happen. In retro engines, this is usually an AABB (Axis-Aligned Bounding Box):\nOffset - Position offset from the entity’s origin to align with the sprite. Size - Defines collision area. Trigger Flag - Marks collider as “non-physical” (no bounce/push, only events). Layer/Mask - Filters what this collider interacts with (e.g., Player layer vs. Enemy layer). Response - None (for triggers) or simple reaction (bounce, stop). 1 2 3 4 5 6 7 8 9 10 11 12 struct Collider ID db ObjectID db 0 Flags db 0 OffsetX db 0 OffsetY db 0 Width db 0 Height db 0 Layer db 0 EventCollision dw 0 EventTrigger db 0 ends Key Insight: A Collider never moves objects — it only reports contacts.\nSee Colliders in action\nWhy Keep Them Separate? Splitting Rigidbody and Collider gives dot8:\nModularity - An object can have physics without collision, or vice versa. Performance - Collider checks can be optimized separately. Flexibility - Triggers and sensors can exist without affecting motion. Rigidbodies and Colliders work together to bring physics to life. One controls movement, the other defines interaction. Simple, but powerful. How will you use them in your game?\n","date":"2025-08-19T00:00:00Z","image":"https://cardosojoao.github.io/p/engine-phsyics/cover_hu_375dcb390a89de65.jpg","permalink":"https://cardosojoao.github.io/p/engine-phsyics/","title":"Game Physics"},{"content":"The dot8 retro game engine is composed of distinct subsystems, each designed with a clear role in mind to ensure smooth collaboration and maintainability. By assigning dedicated responsibilities—such as rendering graphics, processing user input, or managing audio—these modular components interact harmoniously while remaining independent in their logic and operation. This separation not only streamlines development and debugging but also allows for flexibility in updating or swapping out features without disrupting the whole system. The result is an engine where each piece does its job efficiently, contributing to a cohesive and robust framework for building classic gaming experiences.\nPhysic Engine The physics engine handles how objects move and react to forces like velocity and gravity. It updates positions each frame and supports basic dynamics for things like jumping or falling, while keeping performance in mind for 8-bit hardware.\nAudio System The audio system plays music and sound effects using PT3 files. It can trigger sounds from gameplay events and supports music playback that runs independently of the main game loop, giving life to the game world.\nInput System The input system reads controls from the keyboard or joystick and translates them into game actions. It supports responsive input handling for player movement, menu navigation, or interactive gameplay triggers.\nRender Engine The render engine draws all visible objects to the screen based on their position and sprite. It ensures correct layering and only draws what\u0026rsquo;s necessary, keeping the frame rate smooth and the visuals crisp.\nSprite System The sprite system manages visual tiles and frame data used to display characters, enemies, and effects. It pulls graphics from sprite sheets and handles flipping or offsetting for clean and flexible rendering.\nAnimation System This system controls how sprites animate over time. It changes frames based on timing and states, allowing characters to walk, jump, or attack smoothly. It also supports keyframe-based events during animations.\nEntity Manager The entity manager keeps track of all game objects. It handles creating, updating, and removing objects efficiently during gameplay and ensures each object is correctly processed in the game loop.\nScene Manager The scene manager loads and switches between different levels or screens. It resets objects, positions the camera, and prepares the environment when moving between gameplay, menus, or cutscenes\nCollision System The collision system checks for overlaps between objects, like when the player hits a wall or enemy. It uses simple box checks (AABB) and helps the game react to hits, blocks, or pickups instantly.\nTrigger / Event System This system manages special zones or timed actions. When the player steps on a trigger or a timer finishes, it fires an event—like opening a door, playing a sound, or switching animation state.\nCamera System The camera system follows the player or focuses on key areas of the scene. It ensures that only part of the world is visible on screen, adding cinematic control and smooth scrolling to the game.\nAsset Loader The asset loader handles loading sprites, music, level data, and configuration from memory or external files. It prepares everything needed before the game starts or when switching scenes.\nDebug Tools The debug tools provide visibility into what’s happening inside the engine. They can show object positions, active collisions, memory usage, or FPS counters on screen. These tools help test levels, tune performance, and catch bugs quickly—especially useful during development on limited hardware like the Spectrum Next.\nAs I bring all these systems together, I’m turning the dot8 retro game engine into my creative playground right now. Whether I’m debugging, exploring, or building brand new worlds, the engine lets me bring my ideas to life with excitement and ease. I’m proving that with smart design and a passion for games, even the simplest tools can make something truly fun—right here, in this very moment.\n","date":"2025-08-12T00:00:00Z","image":"https://cardosojoao.github.io/p/engine-sub-system/cover_hu_3f73aa82dbb58ab7.jpg","permalink":"https://cardosojoao.github.io/p/engine-sub-system/","title":"Dot8 - Engine Sub Systems"},{"content":"\nIn the engine, entities materialized as game objects, which serve as containers for all relevant data and behaviour. Each game object typically holds references to components such as sprite, physics body, collider, and logic scripts. This modular design allows flexibility in defining varied entities—like players, enemies, items, or triggers—by composing them from shared building blocks.\nGame object properties Id Is a distinct, engine-assigned identifier given to each game object at creation time. It ensures that every object can be individually referenced, tracked, or compared, even if multiple objects share the same type, tag, or position.\nTag A short identifier string or byte value that describes the object’s logical category (e.g., \u0026ldquo;enemy\u0026rdquo;, \u0026ldquo;bullet\u0026rdquo;, \u0026ldquo;checkpoint\u0026rdquo;). Tags are used to group or filter game objects during logic checks, such as collision response or trigger activation. Unlike class types, tags are flexible and can be changed at runtime.\nFlags Is a bitfield property that stores multiple binary (on/off) attributes for a game object using a single byte or word. Each bit in the flags value represents a specific toggleable property or state, such as enabled, or don’t destroy.\nParent is a reference to another game object that acts as the logical or spatial parent of this object. It links a child object to its parent, allowing it to inherit position, state, or behaviour hierarchically.\nX Represents the object\u0026rsquo;s horizontal position within the scene or world coordinate system. It defines how far the object is placed from the left edge of the scene, measured in pixels.\nY Represents the object\u0026rsquo;s vertical position within the scene or world coordinate system. It defines how far the object is placed from the top edge of the scene, measured in pixels.\nFSM A Finite State Machine (FSM) is a way to control behaviour by dividing it into a fixed number of states, where each state defines what the object is doing. At any moment, the object is in one state, and it can switch to another based on conditions or events.\nFSM State is a value that represents the current behaviour or mode of a game object within a finite state machine (FSM). Each value corresponds to a specific state, such as idle, walking, jumping, or attacking.\nCollider The collider component defines the physical size and collision behaviour of a game object. It can be assigned to both rigid and non-rigid entities. The collider does not handle physics simulation itself (e.g. gravity or forces) but acts as a collision shape and provides hooks for event responses when overlapping or contacting other objects.\nRigidbody The Rigidbody component controls how a game object moves over time based on velocity, applied forces, and optionally gravity. It defines dynamic motion separate from collision boundaries, allowing for smooth, physically influenced movement like falling, sliding, or being pushed.\nSprite The Sprite component defines how a game object is visually rendered on screen. It contains information about the sprite’s size, position offset, which spritesheet to use, and the current frame to display from the spritesheet.\nAnimation The Animation component manages how a game object’s sprite is animated over time. It tracks the current animation state, controls the frame rate, steps through keyframes, and handles event triggers tied to specific frames. It also includes a small finite state machine (FSM) to manage transitions between different animations (e.g., idle, walk, jump, attack).\nTimer The Timer component is used to trigger events after a specified number of frames. It can be configured to fire once or loop continuously, making it ideal for timed effects, delays, cooldowns, or periodic actions.\nPath The Path component moves a game object along a predefined series of points, creating automated. It supports a custom speed, directional travel, and options to run once, loop, or ping-pong back and forth.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 struct Object ID db 0 Tag db 0 Flags db 0 PosX dw 0 PosY dw 0 Parent db 0 State db 0 FSM dw 0 SpriteComp db 0 PhysicComp db 0 AnimationComp db 0 ColliderComp db 0 PathComp db 0 TimerComp db 0 ends The Object structure holds all the key data for each entity in the game. It is stored as a fixed-size block in memory, making it easy and fast to access in assembly. This simple layout helps the engine update and draw many objects efficiently, while keeping the code clean and organized.\nAs I continue building the dot8 engine, I constantly find myself relying on the Entity Manager it’s really the heartbeat of everything. Right now, it’s the system that keeps track of all active objects in the scene, from enemies and bullets to triggers and NPCs. It decides which entities get updated, drawn, or removed each frame. Without it, the game world would fall apart. It’s not flashy, but it quietly orchestrates the entire flow of gameplay, ensuring every component knows where it belongs. And as the engine grows, the Entity Manager keeps proving itself as the glue that holds all the pieces together.\n","date":"2025-08-04T00:00:00Z","image":"https://cardosojoao.github.io/p/engine-entities/cover4_hu_923c953f1d8c97a9.jpg","permalink":"https://cardosojoao.github.io/p/engine-entities/","title":"dot8 - Entity Manager"}]