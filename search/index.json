[{"content":"My development environment is based on windows desktop using VSCode as editor with a collections of extension and CSpect for ZX Spectrum Next Emulation and also ZX Spectrum Next hardware.\nTools Visual Studio Code (VS Code) is a lightweight, open-source, and highly extensible code editor from Microsoft that supports multiple programming languages, debugging, Git integration, and a rich ecosystem of extensions for efficient development.\nhttps://code.visualstudio.com/download\nsjasmplus is a powerful Z80 assembler that provides advanced features and flexibility for Spectrum Next development.\nhttps://github.com/z00m128/sjasmplus\nCSpect is a Spectrum Next emulator that delivers near full hardware accuracy, allowing software to run almost exactly as it would on the real machine.\nhttps://mdf200.itch.io/cspect\nGitHub is a platform for hosting and collaborating on code projects, enabling version control and teamwork through Git in the cloud.\nhttps://github.com/\nThe ZX Spectrum Next is a modern reimagining of the classic ZX Spectrum, offering enhanced hardware while staying true to the original’s spirit.\nhttps://www.specnext.com/\nHardware remote debug Remote debugging from real hardware is possible by connecting the ZX Spectrum Next joystick port to your PC via USB.\n6 Pin FTDI FT232RL USB To Serial Adapter módulo USB TO TTL RS232 cabo\nVSCode Extensions VSCode is the beating heart of my coding world, supercharged by countless plugins that make every development task smoother and more powerful.\nI supercharge VSCode with a curated set of extensions that elevate Z80 assembly development to the same power and convenience as modern languages like C.\nASM Code Lens A language server that enables code lens, references, hover information, symbol renaming and the outline view for assembler files.\nhttps://marketplace.visualstudio.com/items?itemName=maziac.asm-code-lens\nDeZog is a powerful Z80 debugger plugin for VSCode, offering advanced tools to make Spectrum Next development efficient and precise.\nMy favourite extension makes debugging easier and more powerful than ever—it’s like a Swiss Army knife for developers.\nhttps://marketplace.visualstudio.com/items?itemName=maziac.dezog\nNEX-FileViewer adds a readonly file viewer for ZX Spectrum NEX files. .nex is a special file format for loading ZX Next programs. The viewer shows registers, a memory dump and the included screen images.\nhttps://marketplace.visualstudio.com/items?itemName=maziac.nex-fileviewer\nZ80 Assembly meters meters clock cycles and bytecode size from Z80 assembly source code.\nForget the T-state cheat sheet, instantly see instruction cycles and byte sizes as you code.\nhttps://marketplace.visualstudio.com/items?itemName=theNestruo.z80-asm-meter\nZ80 Instruction Set Provides documentation of the Z80 instructions on hovering.\nhttps://marketplace.visualstudio.com/items?itemName=maziac.z80-instruction-set\nTodo Tree Show TODO, FIXME, etc. comment tags in a tree view\nhttps://marketplace.visualstudio.com/items?itemName=Gruntfuggly.todo-tree\nResources There’s a massive amount of information out there, you just need to know where to look. Here’s my curated list of the essentials.\nhttps://www.specnext.com/ Spectrum Next discord server https://luckyredfish.com/ https://zx.remysharp.com/ Jim Bagley tutorials https://www.assemblytutorial.com/ http://z80-heaven.wikidot.com/math https://www.patreon.com/c/u27217558/home https://www.patreon.com/c/mikedailly/posts These are the tools and resources that power my development workflow, but they’re by no means the only options out there. The Spectrum Next community is full of amazing alternatives, so explore, experiment, and find the setup that works best for you.\n","date":"2025-08-28T00:00:00Z","image":"https://cardosojoao.github.io/p/development-environment/cover_hu_a3f9d62476c192cc.jpg","permalink":"https://cardosojoao.github.io/p/development-environment/","title":"My developmen environment"},{"content":"Inside the dot8 Physics Engine Building a physics engine isn’t just about moving objects—it’s about creating a consistent and believable world. Rigidbodies define how objects react to forces, gravity, and collisions, while colliders determine the shape and boundaries for those interactions. Together, they form the backbone of any physics simulation, enabling everything from subtle character movement to complex dynamic environments. Understanding how these components work together is key for developers who want precision, performance, and realism in their games. Mastering these fundamentals isn’t just a technical skill—it’s what transforms code into immersive experiences.\nRigidbody: Motion in Action A Rigidbody defines how an entity moves in the game world:\nVelocity - 2D vector for movement per frame. Acceleration - Enables force-based motion. Gravity - Global or per object (set to 0 for flying entities). Damping/Friction - Gradually reduces speed for smooth stops. Integration Step - Updates position each frame with a fixed timestep. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct Rigidbody ID db 0 ObjectID db 0 Flags db 0 VelocityX dw 0 VelocityY dw 0 AccelerationX dw 0 AccelerationY dw 0 FrictionX dw 0 FrictionY dw 0 ConstantAcceleration dw 0 ForceDuration db 0 State db 0 FSM dw 0 ends Key Insight: A Rigidbody doesn’t detect collisions — it only updates position based on forces.\nCollider: The Silent Watcher -A Collider focuses on where interactions happen. In retro engines, this is usually an AABB (Axis-Aligned Bounding Box):\nOffset - Position offset from the entity’s origin to align with the sprite. Size - Defines collision area. Trigger Flag - Marks collider as “non-physical” (no bounce/push, only events). Layer/Mask - Filters what this collider interacts with (e.g., Player layer vs. Enemy layer). Response - None (for triggers) or simple reaction (bounce, stop). 1 2 3 4 5 6 7 8 9 10 11 12 struct Collider ID db ObjectID db 0 Flags db 0 OffsetX db 0 OffsetY db 0 Width db 0 Height db 0 Layer db 0 EventCollision dw 0 EventTrigger db 0 ends Key Insight: A Collider never moves objects — it only reports contacts.\nSee Colliders in action\nWhy Keep Them Separate? Splitting Rigidbody and Collider gives dot8:\nModularity - An object can have physics without collision, or vice versa. Performance - Collider checks can be optimized separately. Flexibility - Triggers and sensors can exist without affecting motion. Rigidbodies and Colliders work together to bring physics to life. One controls movement, the other defines interaction. Simple, but powerful. How will you use them in your game?\n","date":"2025-08-19T00:00:00Z","image":"https://cardosojoao.github.io/p/engine-phsyics/cover_hu_375dcb390a89de65.jpg","permalink":"https://cardosojoao.github.io/p/engine-phsyics/","title":"Game Physics"},{"content":"The dot8 retro game engine is composed of distinct subsystems, each designed with a clear role in mind to ensure smooth collaboration and maintainability. By assigning dedicated responsibilities—such as rendering graphics, processing user input, or managing audio—these modular components interact harmoniously while remaining independent in their logic and operation. This separation not only streamlines development and debugging but also allows for flexibility in updating or swapping out features without disrupting the whole system. The result is an engine where each piece does its job efficiently, contributing to a cohesive and robust framework for building classic gaming experiences.\nPhysic Engine The physics engine handles how objects move and react to forces like velocity and gravity. It updates positions each frame and supports basic dynamics for things like jumping or falling, while keeping performance in mind for 8-bit hardware.\nAudio System The audio system plays music and sound effects using PT3 files. It can trigger sounds from gameplay events and supports music playback that runs independently of the main game loop, giving life to the game world.\nInput System The input system reads controls from the keyboard or joystick and translates them into game actions. It supports responsive input handling for player movement, menu navigation, or interactive gameplay triggers.\nRender Engine The render engine draws all visible objects to the screen based on their position and sprite. It ensures correct layering and only draws what\u0026rsquo;s necessary, keeping the frame rate smooth and the visuals crisp.\nSprite System The sprite system manages visual tiles and frame data used to display characters, enemies, and effects. It pulls graphics from sprite sheets and handles flipping or offsetting for clean and flexible rendering.\nAnimation System This system controls how sprites animate over time. It changes frames based on timing and states, allowing characters to walk, jump, or attack smoothly. It also supports keyframe-based events during animations.\nEntity Manager The entity manager keeps track of all game objects. It handles creating, updating, and removing objects efficiently during gameplay and ensures each object is correctly processed in the game loop.\nScene Manager The scene manager loads and switches between different levels or screens. It resets objects, positions the camera, and prepares the environment when moving between gameplay, menus, or cutscenes\nCollision System The collision system checks for overlaps between objects, like when the player hits a wall or enemy. It uses simple box checks (AABB) and helps the game react to hits, blocks, or pickups instantly.\nTrigger / Event System This system manages special zones or timed actions. When the player steps on a trigger or a timer finishes, it fires an event—like opening a door, playing a sound, or switching animation state.\nCamera System The camera system follows the player or focuses on key areas of the scene. It ensures that only part of the world is visible on screen, adding cinematic control and smooth scrolling to the game.\nAsset Loader The asset loader handles loading sprites, music, level data, and configuration from memory or external files. It prepares everything needed before the game starts or when switching scenes.\nDebug Tools The debug tools provide visibility into what’s happening inside the engine. They can show object positions, active collisions, memory usage, or FPS counters on screen. These tools help test levels, tune performance, and catch bugs quickly—especially useful during development on limited hardware like the Spectrum Next.\nAs I bring all these systems together, I’m turning the dot8 retro game engine into my creative playground right now. Whether I’m debugging, exploring, or building brand new worlds, the engine lets me bring my ideas to life with excitement and ease. I’m proving that with smart design and a passion for games, even the simplest tools can make something truly fun—right here, in this very moment.\n","date":"2025-08-12T00:00:00Z","image":"https://cardosojoao.github.io/p/engine-sub-system/cover_hu_3f73aa82dbb58ab7.jpg","permalink":"https://cardosojoao.github.io/p/engine-sub-system/","title":"Dot8 - Engine Sub Systems"},{"content":"\nIn the engine, entities materialized as game objects, which serve as containers for all relevant data and behaviour. Each game object typically holds references to components such as sprite, physics body, collider, and logic scripts. This modular design allows flexibility in defining varied entities—like players, enemies, items, or triggers—by composing them from shared building blocks.\nGame object properties Id Is a distinct, engine-assigned identifier given to each game object at creation time. It ensures that every object can be individually referenced, tracked, or compared, even if multiple objects share the same type, tag, or position.\nTag A short identifier string or byte value that describes the object’s logical category (e.g., \u0026ldquo;enemy\u0026rdquo;, \u0026ldquo;bullet\u0026rdquo;, \u0026ldquo;checkpoint\u0026rdquo;). Tags are used to group or filter game objects during logic checks, such as collision response or trigger activation. Unlike class types, tags are flexible and can be changed at runtime.\nFlags Is a bitfield property that stores multiple binary (on/off) attributes for a game object using a single byte or word. Each bit in the flags value represents a specific toggleable property or state, such as enabled, or don’t destroy.\nParent is a reference to another game object that acts as the logical or spatial parent of this object. It links a child object to its parent, allowing it to inherit position, state, or behaviour hierarchically.\nX Represents the object\u0026rsquo;s horizontal position within the scene or world coordinate system. It defines how far the object is placed from the left edge of the scene, measured in pixels.\nY Represents the object\u0026rsquo;s vertical position within the scene or world coordinate system. It defines how far the object is placed from the top edge of the scene, measured in pixels.\nFSM A Finite State Machine (FSM) is a way to control behaviour by dividing it into a fixed number of states, where each state defines what the object is doing. At any moment, the object is in one state, and it can switch to another based on conditions or events.\nFSM State is a value that represents the current behaviour or mode of a game object within a finite state machine (FSM). Each value corresponds to a specific state, such as idle, walking, jumping, or attacking.\nCollider The collider component defines the physical size and collision behaviour of a game object. It can be assigned to both rigid and non-rigid entities. The collider does not handle physics simulation itself (e.g. gravity or forces) but acts as a collision shape and provides hooks for event responses when overlapping or contacting other objects.\nRigidbody The Rigidbody component controls how a game object moves over time based on velocity, applied forces, and optionally gravity. It defines dynamic motion separate from collision boundaries, allowing for smooth, physically influenced movement like falling, sliding, or being pushed.\nSprite The Sprite component defines how a game object is visually rendered on screen. It contains information about the sprite’s size, position offset, which spritesheet to use, and the current frame to display from the spritesheet.\nAnimation The Animation component manages how a game object’s sprite is animated over time. It tracks the current animation state, controls the frame rate, steps through keyframes, and handles event triggers tied to specific frames. It also includes a small finite state machine (FSM) to manage transitions between different animations (e.g., idle, walk, jump, attack).\nTimer The Timer component is used to trigger events after a specified number of frames. It can be configured to fire once or loop continuously, making it ideal for timed effects, delays, cooldowns, or periodic actions.\nPath The Path component moves a game object along a predefined series of points, creating automated. It supports a custom speed, directional travel, and options to run once, loop, or ping-pong back and forth.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 struct Object ID db 0 Tag db 0 Flags db 0 PosX dw 0 PosY dw 0 Parent db 0 State db 0 FSM dw 0 SpriteComp db 0 PhysicComp db 0 AnimationComp db 0 ColliderComp db 0 PathComp db 0 TimerComp db 0 ends The Object structure holds all the key data for each entity in the game. It is stored as a fixed-size block in memory, making it easy and fast to access in assembly. This simple layout helps the engine update and draw many objects efficiently, while keeping the code clean and organized.\nAs I continue building the dot8 engine, I constantly find myself relying on the Entity Manager it’s really the heartbeat of everything. Right now, it’s the system that keeps track of all active objects in the scene, from enemies and bullets to triggers and NPCs. It decides which entities get updated, drawn, or removed each frame. Without it, the game world would fall apart. It’s not flashy, but it quietly orchestrates the entire flow of gameplay, ensuring every component knows where it belongs. And as the engine grows, the Entity Manager keeps proving itself as the glue that holds all the pieces together.\n","date":"2025-08-04T00:00:00Z","image":"https://cardosojoao.github.io/p/engine-entities/cover4_hu_923c953f1d8c97a9.jpg","permalink":"https://cardosojoao.github.io/p/engine-entities/","title":"dot8 - Entity Manager"}]